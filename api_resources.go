/*
Opal API

Your Home For Developer Resources.

API version: 1.0
Contact: hello@opal.dev
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package opal

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ResourcesApiService ResourcesApi service
type ResourcesApiService service

type ApiResourceUserAccessStatusRetrieveRequest struct {
	ctx _context.Context
	ApiService *ResourcesApiService
	resourceId string
	userId string
	accessLevelRemoteId *string
	cursor *string
	pageSize *int32
}

// The remote ID of the access level that you wish to query for the resource. If omitted, the default access level remote ID value (empty string) is used.
func (r ApiResourceUserAccessStatusRetrieveRequest) AccessLevelRemoteId(accessLevelRemoteId string) ApiResourceUserAccessStatusRetrieveRequest {
	r.accessLevelRemoteId = &accessLevelRemoteId
	return r
}
// The pagination cursor value.
func (r ApiResourceUserAccessStatusRetrieveRequest) Cursor(cursor string) ApiResourceUserAccessStatusRetrieveRequest {
	r.cursor = &cursor
	return r
}
// Number of results to return per page.
func (r ApiResourceUserAccessStatusRetrieveRequest) PageSize(pageSize int32) ApiResourceUserAccessStatusRetrieveRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiResourceUserAccessStatusRetrieveRequest) Execute() (ResourceUserAccessStatus, *_nethttp.Response, error) {
	return r.ApiService.ResourceUserAccessStatusRetrieveExecute(r)
}

/*
ResourceUserAccessStatusRetrieve Method for ResourceUserAccessStatusRetrieve

Get user's access status to a resource.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param resourceId The ID of the resource.
 @param userId The ID of the user.
 @return ApiResourceUserAccessStatusRetrieveRequest
*/
func (a *ResourcesApiService) ResourceUserAccessStatusRetrieve(ctx _context.Context, resourceId string, userId string) ApiResourceUserAccessStatusRetrieveRequest {
	return ApiResourceUserAccessStatusRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		resourceId: resourceId,
		userId: userId,
	}
}

// Execute executes the request
//  @return ResourceUserAccessStatus
func (a *ResourcesApiService) ResourceUserAccessStatusRetrieveExecute(r ApiResourceUserAccessStatusRetrieveRequest) (ResourceUserAccessStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ResourceUserAccessStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourcesApiService.ResourceUserAccessStatusRetrieve")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resource-user-access-status/{resource_id}/{user_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"resource_id"+"}", _neturl.PathEscape(parameterToString(r.resourceId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", _neturl.PathEscape(parameterToString(r.userId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.accessLevelRemoteId != nil {
		localVarQueryParams.Add("access_level_remote_id", parameterToString(*r.accessLevelRemoteId, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResourceUsersListRequest struct {
	ctx _context.Context
	ApiService *ResourcesApiService
	resourceId *string
	accessLevelRemoteId *string
	cursor *string
	pageSize *int32
}

// The ID of the resource.
func (r ApiResourceUsersListRequest) ResourceId(resourceId string) ApiResourceUsersListRequest {
	r.resourceId = &resourceId
	return r
}
// The remote ID of the access level that you wish to query for the resource. If omitted, the default access level remote ID value (empty string) is used.
func (r ApiResourceUsersListRequest) AccessLevelRemoteId(accessLevelRemoteId string) ApiResourceUsersListRequest {
	r.accessLevelRemoteId = &accessLevelRemoteId
	return r
}
// The pagination cursor value.
func (r ApiResourceUsersListRequest) Cursor(cursor string) ApiResourceUsersListRequest {
	r.cursor = &cursor
	return r
}
// Number of results to return per page.
func (r ApiResourceUsersListRequest) PageSize(pageSize int32) ApiResourceUsersListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiResourceUsersListRequest) Execute() (PaginatedResourceUserList, *_nethttp.Response, error) {
	return r.ApiService.ResourceUsersListExecute(r)
}

/*
ResourceUsersList Method for ResourceUsersList

Returns a list of `ResourceUser` objects.

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResourceUsersListRequest
*/
func (a *ResourcesApiService) ResourceUsersList(ctx _context.Context) ApiResourceUsersListRequest {
	return ApiResourceUsersListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaginatedResourceUserList
func (a *ResourcesApiService) ResourceUsersListExecute(r ApiResourceUsersListRequest) (PaginatedResourceUserList, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PaginatedResourceUserList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ResourcesApiService.ResourceUsersList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/resource-users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.resourceId == nil {
		return localVarReturnValue, nil, reportError("resourceId is required and must be specified")
	}

	localVarQueryParams.Add("resource_id", parameterToString(*r.resourceId, ""))
	if r.accessLevelRemoteId != nil {
		localVarQueryParams.Add("access_level_remote_id", parameterToString(*r.accessLevelRemoteId, ""))
	}
	if r.cursor != nil {
		localVarQueryParams.Add("cursor", parameterToString(*r.cursor, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("page_size", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
